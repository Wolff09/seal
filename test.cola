
struct Node {
	data_t data;
	Node* next;
}

Node* Tail;
Node* Head;

extern void retire(Node* ptr);
extern void protect1(Node* ptr);
extern void protect2(Node* ptr);

void init() {
	Head = malloc;
	Head->next = NULL;
	Tail = Head;
}

void enqueue(data_t input) {
	Node* tail, next, node, tmp;
	bool done;
	bool b1;

	node = malloc;
	node->data = input;
	node->next = NULL;

	done = false;
	while (!done) {
		tail = Tail;
		protect1(tail);
		choose {
			atomic {
				tail = Tail;
				protect1(tail);
				assert(active(tail)); /* TO INFER */
			}

			next = tail->next;
			@invariant(active(Tail)) /* TO INFER */
			if (tail == Tail) {

				if (next != NULL) {
					// CAS(Tail, tail, next)
					atomic {
						@invariant(active(Tail)) /* TO INFER */
						if (Tail == tail) {
							Tail = next;
						}
					}

				} else {
					// if (CAS(tail->next, next, node))
					atomic {
						tmp = tail->next;
						if (tmp == NULL) {
							tail->next = node;
							b1 = true;
						} else {
							b1 = false;
						}
					}
					if (b1) {
						// CAS(Tail, tail, node)
						atomic {
							@invariant(active(Tail)) /* TO INFER */
							if (Tail == tail) {
								Tail = node;
							}
						}
						done = true;
					}
				}
			}

		}{
			assume(tail != Tail);
		}
	}
}

data_t dequeue() {
	Node* head, next, tail, tmp;
	data_t result;
	bool done;
	bool b1;

	done = false;
	while (!done) {
		head = Head;
		protect1(head);
		choose {
			atomic {
				head = Head;
				protect1(head);
			}

			tail = Tail;
			next = head->next;
			protect2(next);
			if (head == Head) {
				if (next == NULL) {
					result = EMPTY;
					done = true;

				} else {
					if (head == tail) {
						// CAS(Tail, tail, next)
						atomic {
							if (Tail == tail) {
								Tail = next;
							}
						}

					} else {
						result = next->data;
						// if (CAS(Head, head, next))
						atomic {
							if (Head == head) {
								Head = next;
								b1 = true;
								retire(head);
							} else {
								b1 = false;
							}
							if (b1) {
								// retire(head); // move left to avoid CAVE imprecision
								done = true;
							}
						}
					}
				}
			}

		}{
			assume(head != Head);
		}
	}
	return result;
}
